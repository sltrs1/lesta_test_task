#include "iseven.h"

/*
 * Функция, данная как образец. Использует прямое определение четности,
 * т.е. проверяет остаток от деления на 2.
 * Преимуществом этого способа является его простота и очевидность.
*/
bool isEven(int value) {
    return value % 2 == 0;
}

/*
 * Другим классическим способом проверки четности является проверка
 * бита четности (самого младшего бита).
 * У нечетного числа он установлен в 1, у четного - в 0.
 * Для проверки используется битовая операция & (AND)
 * со значением, у которого младший бит равен 1 (индикатор для проверки),
 * а остальные биты равны 0 (т.е. игнорируются все биты проверяемого числа,
 * кроме бита четности.)
 * Если число нечетное, то результатом такой операции будет 1, то есть, true.
 * Чтобы соответствовать сигнатуре функции, этот результат инвертируется.
 *
 * Преимуществом этого способа являкется его быстродействие,
 * т.к. битовые операции выполняются быстрее, чем операция
 * деления с остатком в функции isEven.
 *
 * ОДНАКО
 * Есть подозрение, что компилятор распознает проверку четности в функции
 * isEven и в функции isEvenBit и соптимизирует их в одинаковый ассемблерный код,
 * так что разницы между ними не будет.
*/
bool isEvenBit(int value) {
    return !(value & 1);
}

/*
 * В качестве еще одного метода проверки можно использовать свойства
 * типа int в языке.
 * Последовательное деление и умножение числа на 2 сначала
 * выполнит смешение на 1 разряд вправо, а затем приведет
 * число к исходному виду, за исключением младшего бита, который станет равен 0.
 * Если он и раньше был равен 0 (число четное), то ничего не изменится
 * и число будет равно само себе, иначе - не будет.
 *
 * Этот метод не имеет никаких приемуществ перед вышеприведенными и в целом бесполезен.
 * Он приведен здесь только потому, что в задании сказано привести метод,
 * от личный по своей сути от данного примера.
*/
bool isEvenInt(int value){
    return (value/2)*2 == value;
}
